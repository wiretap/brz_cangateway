//0000CADC 00 00 01 11 dword_CADC:     .data.l h'111           ; DATA XREF: ROM:CAN_Channel_Setup_Vectoro
//0000CAE0 00 00 00 00                 .data.l 0
//0000CAE4 00 08 00 00                 .data.l loc_80000
//0000CAE8 00 00 07 DF dword_CAE8:     .data.l h'7DF           ; DATA XREF: ROM:0000CC60o
//0000CAEC 00 00 00 00                 .datab.b 4, 0
//0000CAF0 00 08 00 00                 .data.l loc_80000
//0000CAF4 00 00 07 E0 dword_CAF4:     .data.l h'7E0           ; DATA XREF: ROM:0000CC64o
//0000CAF8 00 00 00 00                 .data.l 0
//0000CAFC 00 08 00 00                 .data.l loc_80000
//0000CB00 00 00 07 E8 dword_CB00:     .data.l h'7E8           ; DATA XREF: ROM:0000CC68o
//0000CB04 00 00 00 00                 .data.l 0
//0000CB08 00 08 00 00                 .data.l loc_80000
//0000CB0C 00 00 07 71 dword_CB0C:     .data.l h'771           ; DATA XREF: ROM:0000CC6Co
//0000CB10 00 00 00 00                 .data.l 0
//0000CB14 00 08 00 00                 .data.l loc_80000
//0000CB18 00 00 07 72 dword_CB18:     .data.l h'772           ; DATA XREF: ROM:0000CC70o
//0000CB1C 00 00 00 00                 .data.l 0
//0000CB20 00 08 00 00                 .data.l loc_80000
//0000CB24 00 00 07 73 dword_CB24:     .data.l h'773           ; DATA XREF: ROM:0000CC74o
//0000CB28 00 00 00 00                 .data.l 0
//0000CB2C 00 08 00 00                 .data.l loc_80000
//0000CB30 00 00 07 74 dword_CB30:     .data.l h'774           ; DATA XREF: ROM:0000CC78o
//0000CB34 00 00 00 00                 .data.l 0
//0000CB38 00 08 00 00                 .data.l loc_80000
//0000CB3C 00 00 07 75 dword_CB3C:     .data.l h'775           ; DATA XREF: ROM:0000CC7Co
//0000CB40 00 00 00 00                 .data.l 0
//0000CB44 00 08 00 00                 .data.l loc_80000
//0000CB48 00 00 01 40 dword_CB48:     .data.l h'140           ; DATA XREF: ROM:0000CC80o
//0000CB48                                                     ; sub_3D304+19Eo ...
//0000CB4C FF F8 88 74                 .data.l dword_FFF88874
//0000CB50 00 08 00 00                 .data.l loc_80000
//0000CB54 00 00 01 41 dword_CB54:     .data.l h'141           ; DATA XREF: ROM:0000CC84o
//0000CB54                                                     ; sub_3D522+1B0o ...
//0000CB58 FF F8 88 7C                 .data.l dword_FFF8887C
//0000CB5C 00 08 00 00                 .data.l h'80000
//0000CB60 00 00 01 42 dword_CB60:     .data.l h'142           ; DATA XREF: ROM:0000CC88o
//0000CB60                                                     ; sub_3D6EE+76o ...
//0000CB64 FF F8 88 84                 .data.l dword_FFF88884
//0000CB68 00 08 00 00                 .data.l h'80000
//0000CB6C 00 00 01 44 dword_CB6C:     .data.l h'144           ; DATA XREF: ROM:0000CC8Co
//0000CB6C                                                     ; sub_3D7DC+2D0o ...
//0000CB70 FF F8 88 8C                 .data.l dword_FFF8888C
//0000CB74 00 08 00 00                 .data.l h'80000
//0000CB78 00 00 03 60 dword_CB78:     .data.l h'360           ; DATA XREF: ROM:0000CC90o
//0000CB78                                                     ; sub_3DAC0+184o ...
//0000CB7C FF F8 88 94                 .data.l dword_FFF88894
//0000CB80 00 08 00 00                 .data.l h'80000
//0000CB84 00 00 03 61 dword_CB84:     .data.l h'361           ; DATA XREF: ROM:0000CC94o
//0000CB84                                                     ; sub_3DCC0+1AAo ...
//0000CB88 FF F8 88 9C                 .data.l dword_FFF8889C
//0000CB8C 00 08 00 00                 .data.l h'80000
//0000CB90 00 00 04 C1 dword_CB90:     .data.l h'4C1           ; DATA XREF: ROM:0000CC98o
//0000CB90                                                     ; sub_3DE82+24o ...
//0000CB94 FF F8 88 A4                 .data.l dword_FFF888A4
//0000CB98 00 08 00 00                 .data.l h'80000
//0000CB9C 00 00 00 D1 dword_CB9C:     .data.l h'D1            ; DATA XREF: ROM:0000CC9Co
//0000CBA0 FF F8 8C 63                 .data.l unk_FFF88C63
//0000CBA4 00 04 00 00                 .data.l h'40000
//0000CBA8 00 00 00 D2 dword_CBA8:     .data.l h'D2            ; DATA XREF: ROM:0000CCA0o
//0000CBAC FF F8 8C 67                 .data.l unk_FFF88C67
//0000CBB0 00 08 00 00                 .data.l h'80000
//0000CBB4 00 00 00 D3 dword_CBB4:     .data.l h'D3            ; DATA XREF: ROM:0000CCA4o
//0000CBB8 FF F8 8C 6F                 .data.l unk_FFF88C6F
//0000CBBC 00 07 00 00                 .data.l h'70000
//0000CBC0 00 00 00 D4 dword_CBC0:     .data.l h'D4            ; DATA XREF: ROM:0000CCA8o
//0000CBC4 FF F8 8C 76                 .data.l unk_FFF88C76
//0000CBC8 00 08 00 00                 .data.l h'80000
//0000CBCC 00 00 01 48 dword_CBCC:     .data.l h'148           ; DATA XREF: ROM:0000CCACo
//0000CBD0 FF F8 8B 48                 .data.l unk_FFF88B48
//0000CBD4 00 08 00 00                 .data.l h'80000
//0000CBD8 00 00 01 49 dword_CBD8:     .data.l h'149           ; DATA XREF: ROM:0000CCB0o
//0000CBDC FF F8 8B 50                 .data.l unk_FFF88B50
//0000CBE0 00 08 00 00                 .data.l h'80000
//0000CBE4 00 00 01 4A dword_CBE4:     .data.l h'14A           ; DATA XREF: ROM:0000CCB4o
//0000CBE8 FF F8 8B 58                 .data.l unk_FFF88B58
//0000CBEC 00 08 00 00                 .data.l h'80000
//0000CBF0 00 00 03 68 dword_CBF0:     .data.l h'368           ; DATA XREF: ROM:0000CCB8o
//0000CBF4 FF F8 8B 60                 .data.l unk_FFF88B60
//0000CBF8 00 08 00 00                 .data.l h'80000
//0000CBFC 00 00 01 52 dword_CBFC:     .data.l h'152           ; DATA XREF: ROM:0000CCBCo
//0000CC00 FF F8 8B DD                 .data.l unk_FFF88BDD
//0000CC04 00 08 00 00                 .data.l h'80000
//0000CC08 00 00 06 3B dword_CC08:     .data.l h'63B           ; DATA XREF: ROM:0000CCC0o
//0000CC0C FF F8 8B E5                 .data.l unk_FFF88BE5
//0000CC10 00 08 00 00                 .data.l h'80000
//0000CC14 00 00 02 80 dword_CC14:     .data.l h'280           ; DATA XREF: ROM:0000CCC4o
//0000CC18 FF F8 8A 28                 .data.l dword_FFF88A28
//0000CC1C 00 08 00 00                 .data.l h'80000
//0000CC20 00 00 02 82 dword_CC20:     .data.l h'282           ; DATA XREF: ROM:0000CCC8o
//0000CC24 FF F8 8A 66                 .data.l unk_FFF88A66
//0000CC28 00 08 00 00                 .data.l h'80000
//0000CC2C 00 00 03 70 dword_CC2C:     .data.l h'370           ; DATA XREF: ROM:0000CCCCo
//0000CC30 FF F8 8A 98                 .data.l dword_FFF88A98
//0000CC34 00 08 00 00                 .data.l h'80000
//0000CC38 00 00 03 72 dword_CC38:     .data.l h'372           ; DATA XREF: ROM:0000CCD0o
//0000CC3C FF F8 8A BC                 .data.l byte_FFF88ABC
//0000CC40 00 08 00 00                 .data.l h'80000
//0000CC44 00 00 07 20 dword_CC44:     .data.l h'720           ; DATA XREF: ROM:0000CCD4o
//0000CC48 00 00 00 00                 .data.l 0
//0000CC4C 00 08 00 00                 .data.l h'80000
//0000CC50 00 00 00 D0 dword_CC50:     .data.l h'D0            ; DATA XREF: ROM:0000CCD8o
//0000CC54 FF F8 8C 5B                 .data.l unk_FFF88C5B
//0000CC58 00 08 00 00                 .data.l h'80000

short SuspectIDs[] = { 
  0x111, 
  0x7DF, 
  0x7E0, 
  0x7E8, 
  0x771, 
  0x772, 
  0x773, 
  0x774, 
  0x775, 
  0x140, //TX?: 0 byte AccelPedalPositionA, 1 byte Flags (8 bit clutch), 2 long RPM, 4 byte AccelPedalPositionB, 5 byte AccelPedalPositionC, ?
  0x141, //TX?: 6 byte GearIndicator
  0x142, //TX?:
  0x144, //TX?: 2 byte OilTemp, 3 byte CoolantTemp
  0x360, //TX?:
  0x361, //TX?:
  0x4C1, //TX?:
  0xD1,  //RX : 0 long VehicleSpeed, 2 byte BrakePedalPressure
  0xD2,
  0xD3,
  0xD4,  //RX : 0 long VSS_LF, 2 long VSS_RF, 4 long VSS_LR, 6 long VSS_RR
  0x148,
  0x149,
  0x14A,
  0x368,
  0x152, //RX : 8 byte LightingControl/Wipers
  0x63B,
  0x280,
  0x282,
  0x370,
  0x372,
  0x720,
  0xD0   //RX : 0 long Steering Angle
};


#define CIRCULAR_BUFFER_XS
#define CIRCULAR_BUFFER_INT_SAFE

// Required libraries
#include "variant.h"
#include <due_can.h>
#include <CircularBuffer.h>
#include <DueTimer.h>

//Leave defined if you use native port, comment if using programming port
//This sketch could provide a lot of traffic so it might be best to use the
//native port
#define Serial SerialUSB


#define CANLED1 14
#define CANLED2 15


//System timers.
#define HeartbeatTimer Timer0
#define CAN0txTimer Timer1
#define CAN1txTimer Timer2
#define CAN0TestTimer Timer3
#define CAN1TestTimer Timer4

//Setup for test mode frames
#define CAN0_TEST_INTERVAL 325000
#define CAN1_TEST_INTERVAL 860000

//Transparently bridge frames 0-to-1 or 1-to-0
#define CAN_BRIDGE_TRANSPARENT_01 1
#define CAN_BRIDGE_TRANSPARENT_10 1

//Exclude test frames from bridging
#define CAN_BRIDGE_EXCLUDE_TEST 1

//Enable/Disable test mode
//#define CAN_TESTING


#ifdef CAN_TESTING
CAN_FRAME Can1_TestFrame, Can0_TestFrame;
#endif

//TX and RX buffers for CANBus
CircularBuffer<CAN_FRAME,16> CAN_rxBuffer[2], CAN_txBuffer[2];

bool GPLoopFlag;
byte GPLoopIter;

void printFrame(int port, CAN_FRAME *frame) {
   Serial.print("Port: ");
   Serial.print(port);
   Serial.print(" ID: 0x");
   Serial.print(frame->id, HEX);
   Serial.print(" Len: ");
   Serial.print(frame->length);
   Serial.print(" Data: 0x ");
   for (int count = 0; count < frame->length; count++) {
       Serial.print(frame->data.bytes[count], HEX);
       Serial.print(" ");
   }
   Serial.print("\n");
}

void CANactivity(int port){
  switch (port) {
    case 0:
      digitalWrite(CANLED1, !(digitalRead(CANLED1)));
      break;
    case 1:
      digitalWrite(CANLED2, !(digitalRead(CANLED2)));
      break;
    default:
      break;
  }
}

void CAN0rxFrame(CAN_FRAME *frame) 
{
  CANactivity(0);
  CAN_rxBuffer[0].push(*frame);
  if(CAN_BRIDGE_TRANSPARENT_01){
    #ifdef CAN_TESTING
    if((CAN_BRIDGE_EXCLUDE_TEST && (frame->id != Can0_TestFrame.id) && (frame->id != Can1_TestFrame.id)) || (!CAN_BRIDGE_EXCLUDE_TEST)){
    #endif
      CAN_txBuffer[1].push(*frame);
    #ifdef CAN_TESTING
    };    
    #endif
  };
  CANactivity(0);
}

void CAN1rxFrame(CAN_FRAME *frame) 
{
  CANactivity(1);
  CAN_rxBuffer[1].push(*frame);
  if(CAN_BRIDGE_TRANSPARENT_10){
    #ifdef CAN_TESTING
    if((CAN_BRIDGE_EXCLUDE_TEST && (frame->id != Can0_TestFrame.id) && (frame->id != Can1_TestFrame.id))){
    #endif
      CAN_txBuffer[0].push(*frame);
    #ifdef CAN_TESTING
    };
    #endif
  };
  CANactivity(1);
}

void CAN0txFrame()
{
  if(!CAN_txBuffer[0].isEmpty()){
    CANactivity(0);
    while(!CAN_txBuffer[0].isEmpty()){
      CAN_FRAME frame = CAN_txBuffer[0].shift();
      Can0.sendFrame(frame);
    }
    CANactivity(0);
  }
}


void CAN1txFrame()
{
if(!CAN_txBuffer[1].isEmpty()){
    CANactivity(1);
    while(!CAN_txBuffer[1].isEmpty()){
      CAN_FRAME frame = CAN_txBuffer[1].shift();
      Can1.sendFrame(frame);
    }
    CANactivity(1);
  }
}

void HeartbeatLED()
{
  digitalWrite(LED_BUILTIN, !(digitalRead(LED_BUILTIN)));
}

#ifdef CAN_TESTING
void CAN0SendTestFrame()
{
  //Can0.sendFrame(Can0_TestFrame);
  CAN_txBuffer[0].push(Can0_TestFrame);
}

void CAN1SendTestFrame()
{
  //Can1.sendFrame(Can1_TestFrame);
  CAN_txBuffer[1].push(Can1_TestFrame);
}
#endif

void setup()
{

  pinMode(CANLED1, OUTPUT);
  digitalWrite(CANLED1, HIGH);
  pinMode(CANLED2, OUTPUT);
  digitalWrite(CANLED2, HIGH);
  pinMode(LED_BUILTIN, OUTPUT);
  digitalWrite(LED_BUILTIN, HIGH);
  Serial.begin(1000000);
  
  // Initialize CAN0, Set the proper baud rates here
  if(Can0.begin(CAN_BPS_500K)){
    digitalWrite(CANLED1, LOW);
  }
  if(Can1.begin(CAN_BPS_500K)){
    digitalWrite(CANLED2, LOW);
  }

  Can0.setNumTXBoxes(4);
  Can0.watchFor();
  Can0.setGeneralCallback(CAN0rxFrame);

  Can1.setNumTXBoxes(4);
  Can1.watchFor();
  Can1.setGeneralCallback(CAN1rxFrame);

#ifdef CAN_TESTING 
  Can0_TestFrame.id=0x123;
  Can0_TestFrame.data.low=0x08070605;
  Can0_TestFrame.data.high=0x04030201;
  Can0_TestFrame.length=8;
  Can0_TestFrame.extended=0;
  Can1_TestFrame.id=0x7F0;
  Can1_TestFrame.data.low=0x01020304;
  Can1_TestFrame.data.high=0x05060708;
  Can1_TestFrame.length=8;
  Can1_TestFrame.extended=0;
#endif

  //Flash the status LED at 125ms via interrupts
  HeartbeatTimer.attachInterrupt(HeartbeatLED).start(125000);

  //Can TX timers running at 12.5ms intervals
  CAN0txTimer.attachInterrupt(CAN0txFrame).start(12500);
  CAN1txTimer.attachInterrupt(CAN1txFrame).start(12500);

#ifdef CAN_TESTING
  CAN0TestTimer.attachInterrupt(CAN0SendTestFrame).start(CAN0_TEST_INTERVAL);
  CAN1TestTimer.attachInterrupt(CAN1SendTestFrame).start(CAN1_TEST_INTERVAL);
#endif
  
}

void loop(){ 
  //Run through receive buffers and print output to serial port
  for(int i=0; i<=1; i++)
  {
    if(!CAN_rxBuffer[i].isEmpty()){
      while(!CAN_rxBuffer[i].isEmpty()){
        CAN_FRAME frame = CAN_rxBuffer[i].shift();
        printFrame(i,&frame);
      }
    }
  } 
}
